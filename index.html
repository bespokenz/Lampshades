<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bespoke Shade Maker — Lampshade Pattern PWA</title>
  <meta name="theme-color" content="#2b6cb0">
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <style>
    :root{--bg:#f7fbff;--card:#fff;--accent:#2b6cb0;--muted:#637381}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans',sans-serif;background:var(--bg);color:#0b1220;font-size:20px;touch-action:manipulation}
    .wrap{max-width:800px;margin:8px auto;padding:8px}
    header{display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:22px}
    .card{background:var(--card);border-radius:12px;padding:10px;box-shadow:0 3px 10px rgba(11,18,32,.10);margin-bottom:10px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
    label{display:block;font-size:15px;color:var(--muted);margin-bottom:6px}
    input[type=number],select{width:100%;padding:14px 8px;border-radius:8px;border:1px solid #e6eef6;font-size:18px}
    .row{display:flex;gap:8px}
    .small{width:120px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:14px;flex-wrap:wrap;}
    button{background:var(--accent);border:none;color:white;padding:18px 0;border-radius:8px;font-weight:600;cursor:pointer;font-size:18px;width:100%;margin-top:8px;transition:opacity 0.2s}
    button:hover{opacity:0.9}
    button:disabled{opacity:0.5;cursor:not-allowed}
    .footer,.info{font-size:15px;color:var(--muted);margin-top:12px}
    .status{margin-top:8px;padding:8px;border-radius:6px;font-size:14px;display:none}
    .status.show{display:block}
    .status.success{background:#d1fae5;color:#065f46}
    .status.error{background:#fee2e2;color:#991b1b}
    .status.info{background:#dbeafe;color:#1e40af}
    @media (max-width:700px){body{font-size:22px;}.wrap{max-width:none;margin:0;padding:0}.grid{grid-template-columns:1fr}.card{padding:8px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="display:inline-flex;padding:10px 14px;align-items:center;gap:12px">
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden>
          <path d="M12 2l2.5 5 5.5 1-4 4 1 5.5L12 16l-5 3.5L8 12 4 8l5.5-1L12 2z" fill="#2b6cb0" />
        </svg>
        <div>
          <h1>Bespoke Shade Maker</h1>
          <div style="font-size:13px;color:var(--muted)">Create printable lampshade templates — PWA-ready</div>
        </div>
      </div>
      <div style="flex:1"></div>
    </header>
    <div class="grid">
      <div class="card">
        <h2 style="margin:0 0 8px 0">Inputs</h2>
        <div style="display:grid;gap:10px">
          <div>
            <label>Units</label>
            <div class="row">
              <select id="unit">
                <option value="mm">Millimetres (mm)</option>
                <option value="in">Inches (in)</option>
              </select>
            </div>
          </div>
          <div class="row">
            <div style="flex:1">
              <label>Top diameter</label>
              <input id="topD" type="number" step="0.1" min="1" value="150" />
            </div>
            <div style="flex:1">
              <label>Bottom diameter</label>
              <input id="botD" type="number" step="0.1" min="1" value="300" />
            </div>
          </div>
          <div>
            <label>Height (vertical)</label>
            <input id="height" type="number" step="0.1" min="1" value="220" />
          </div>
          <div class="row">
            <div style="flex:1">
              <label>Seam allowance (along straight edge)</label>
              <input id="seam" type="number" step="0.1" min="0" value="10" />
            </div>
            <div style="flex:1">
              <label>Bend allowance (top/bottom fold)</label>
              <input id="fold" type="number" step="0.1" min="0" value="8" />
            </div>
          </div>
          <div>
            <label>Scale to fit page width when printing</label>
            <select id="paperScale">
              <option value="fit">Fit to page width (A4/Letter)</option>
              <option value="1">1:1 (actual size - may span multiple pages)</option>
              <option value="0.5">50% scale</option>
            </select>
          </div>
          <div class="controls">
            <button id="openPdfBtn" style="width:48%;">Open PDF</button>
            <button id="printPdfBtn" style="width:48%;">Print PDF</button>
          </div>
          <div id="statusMessage" class="status"></div>
          <div class="info">
            This generator calculates the unwrapped lateral surface of a lampshade (truncated cone). The template will be exported as a printable PDF. For 1:1 scale, large patterns may span multiple pages - align the dashed edges to assemble.
          </div>
        </div>
      </div>
    </div>
    <footer style="margin-top:14px;text-align:center;color:var(--muted);font-size:13px">Lampshade pattern generator</footer>
  </div>
  <script>
    // --- PDF + Geometry Utilities ---
    function toMM(value, unit){ return unit === 'mm' ? Number(value) : Number(value) * 25.4; }
    function fromMM(value, unit){ return unit === 'mm' ? value : value / 25.4; }
    
    function computeAnnularSector(r1, r2, h){
      if (r2 === r1) r2 = r1 + 0.00001;
      const s = Math.sqrt((r2 - r1) * (r2 - r1) + h * h);
      const L2 = s * r2 / (r2 - r1);
      const L1 = s * r1 / (r2 - r1);
      const theta = 2 * Math.PI * (r2 - r1) / s;
      return {s, L1, L2, theta};
    }
    
    function polarToCartesian(r, angle, cx, cy){
      return {x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle)};
    }

    function showStatus(message, type = 'info') {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status show ' + type;
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          statusEl.classList.remove('show');
        }, 5000);
      }
    }

    function validateInputs() {
      const topD = Number(document.getElementById('topD').value);
      const botD = Number(document.getElementById('botD').value);
      const height = Number(document.getElementById('height').value);
      
      if (topD <= 0 || botD <= 0 || height <= 0) {
        throw new Error('All dimensions must be positive numbers');
      }
      if (topD >= botD) {
        throw new Error('Top diameter must be smaller than bottom diameter');
      }
      return true;
    }

    async function generatePdfBlob() {
      try {
        validateInputs();
        
        // Wait for pdf-lib to load
        let attempts = 0;
        while (!window.PDFLib && !window['pdf-lib'] && attempts < 50) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        const unit = document.getElementById('unit').value;
        const topD = Number(document.getElementById('topD').value);
        const botD = Number(document.getElementById('botD').value);
        const height = Number(document.getElementById('height').value);
        const seam = Number(document.getElementById('seam').value);
        const fold = Number(document.getElementById('fold').value);
        const paperScale = document.getElementById('paperScale').value;
        
        const PDFLib = window.PDFLib || window['pdf-lib'];
        if (!PDFLib || !PDFLib.PDFDocument) {
          throw new Error('PDF library not loaded. Please refresh the page and try again.');
        }
        
        const { PDFDocument } = PDFLib;
        const pdfDoc = await PDFDocument.create();

        // PDF: A4 (595x842pt)
        const pageWidth = 595, pageHeight = 842, margin = 28;
        const MM_TO_PT = 2.83465; // 1 mm = 2.83465 pt
        
        // Geometry calculations in mm
        const topR = toMM(topD/2, unit), botR = toMM(botD/2, unit), h = toMM(height, unit);
        const seamMM = toMM(seam, unit), foldMM = toMM(fold, unit);
        const geom = computeAnnularSector(topR, botR, h);
        
        // sector radii in mm
        const rInner = geom.L1 + foldMM;
        const rOuter = geom.L2 + foldMM + seamMM;
        const angleSpan = geom.theta; // radians

        // --- SCALING LOGIC ---
        let scale;
        if (paperScale === "fit") {
          const drawMaxR = Math.min((pageWidth - 2 * margin), (pageHeight - 2 * margin - 60)) / 2;
          scale = drawMaxR / rOuter;
        } else if (paperScale === "1") {
          scale = MM_TO_PT;
        } else {
          const drawMaxR = Math.min((pageWidth - 2 * margin), (pageHeight - 2 * margin - 60)) / 2;
          scale = drawMaxR / rOuter * parseFloat(paperScale);
        }

        // Calculate if pattern needs pagination
        const outerRadiusPt = rOuter * scale;
        const innerRadiusPt = rInner * scale;
        
        let currentAngle = -angleSpan/2;
        let pageNum = 1;
        
        // Determine max segment angle per page
        let maxSegment;
        if (paperScale === "1") {
          const availableWidth = pageWidth - 2 * margin;
          const availableHeight = pageHeight - 2 * margin - 80;
          const maxRadiusForPage = Math.min(availableWidth, availableHeight) / 2;
          
          if (outerRadiusPt <= maxRadiusForPage) {
            maxSegment = angleSpan;
          } else {
            // Calculate chord-based max angle
            const safeChordRatio = 0.85; // Safety factor
            const maxChordLength = availableWidth * safeChordRatio;
            let maxAngle = 2 * Math.asin(Math.min(1, maxChordLength / (2 * outerRadiusPt)));
            maxSegment = Math.max(Math.min(maxAngle, angleSpan), Math.PI / 6); // Min 30 degrees
          }
        } else {
          maxSegment = angleSpan; // Single page for scaled versions
        }

        while (currentAngle < angleSpan/2 - 0.0001) {
          const thisStart = currentAngle;
          const thisEnd = Math.min(currentAngle + maxSegment, angleSpan/2);

          // Create high-res canvas
          const pixelRatio = 2; // For better quality
          const canvas = document.createElement('canvas');
          canvas.width = pageWidth * pixelRatio;
          canvas.height = pageHeight * pixelRatio;
          const ctx = canvas.getContext('2d', { alpha: false });
          ctx.scale(pixelRatio, pixelRatio);

          // White background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, pageWidth, pageHeight);

          // Draw title
          ctx.fillStyle = '#1f2d55';
          ctx.font = 'bold 16px system-ui, sans-serif';
          const totalPages = Math.ceil((angleSpan) / maxSegment);
          ctx.fillText(`Lampshade Template - Page ${pageNum}${totalPages > 1 ? ' of ' + totalPages : ''}`, margin, 40);

          // Calculate center position
          let cx = pageWidth / 2;
          let cy = pageHeight / 2 + 20;
          
          if (paperScale === "1") {
            // Better centering for 1:1 scale
            const segmentMidAngle = (thisStart + thisEnd) / 2;
            
            // Calculate bounds of this segment
            const outerPoints = [
              polarToCartesian(outerRadiusPt, thisStart, 0, 0),
              polarToCartesian(outerRadiusPt, thisEnd, 0, 0)
            ];
            const innerPoints = [
              polarToCartesian(innerRadiusPt, thisStart, 0, 0),
              polarToCartesian(innerRadiusPt, thisEnd, 0, 0)
            ];
            
            const allPoints = [...outerPoints, ...innerPoints];
            const minY = Math.min(...allPoints.map(p => p.y));
            const maxY = Math.max(...allPoints.map(p => p.y));
            const minX = Math.min(...allPoints.map(p => p.x));
            const maxX = Math.max(...allPoints.map(p => p.x));
            
            const height = maxY - minY;
            const width = maxX - minX;
            
            cx = pageWidth / 2 - (minX + maxX) / 2;
            cy = 70 - minY + (pageHeight - 100 - height) / 2;
          }

          // Build and draw the annular sector
          const steps = Math.max(180, Math.floor((thisEnd - thisStart) * 180 / Math.PI));
          
          ctx.beginPath();
          // Outer arc
          for (let i = 0; i <= steps; i++) {
            const t = thisStart + (thisEnd - thisStart) * (i / steps);
            const p = polarToCartesian(outerRadiusPt, t, cx, cy);
            if (i === 0) ctx.moveTo(p.x, p.y); 
            else ctx.lineTo(p.x, p.y);
          }
          // Inner arc (reversed)
          for (let i = steps; i >= 0; i--) {
            const t = thisStart + (thisEnd - thisStart) * (i / steps);
            const p = polarToCartesian(innerRadiusPt, t, cx, cy);
            ctx.lineTo(p.x, p.y);
          }
          ctx.closePath();

          // Fill and stroke main shape
          ctx.fillStyle = '#ffffff';
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#2b6cb0';
          ctx.stroke();

          // Dashed radial edges for alignment
          const startPtOut = polarToCartesian(outerRadiusPt, thisStart, cx, cy);
          const startPtIn = polarToCartesian(innerRadiusPt, thisStart, cx, cy);
          const endPtOut = polarToCartesian(outerRadiusPt, thisEnd, cx, cy);
          const endPtIn = polarToCartesian(innerRadiusPt, thisEnd, cx, cy);

          ctx.setLineDash([8, 5]);
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 1.5;
          
          ctx.beginPath();
          ctx.moveTo(startPtOut.x, startPtOut.y);
          ctx.lineTo(startPtIn.x, startPtIn.y);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(endPtOut.x, endPtOut.y);
          ctx.lineTo(endPtIn.x, endPtIn.y);
          ctx.stroke();
          ctx.setLineDash([]);

          // Page join labels
          if (totalPages > 1) {
            ctx.fillStyle = '#7c2d12';
            ctx.font = 'bold 12px system-ui, sans-serif';
            
            if (thisEnd < angleSpan / 2 - 0.0001) {
              const labelPos = polarToCartesian((outerRadiusPt + innerRadiusPt) / 2, thisEnd, cx, cy);
              const labelText = `→ Align to Page ${pageNum + 1}`;
              ctx.fillText(labelText, labelPos.x + 15, labelPos.y + 5);
            }
            if (pageNum > 1) {
              const labelPos = polarToCartesian((outerRadiusPt + innerRadiusPt) / 2, thisStart, cx, cy);
              const labelText = `Align to Page ${pageNum - 1} ←`;
              const metrics = ctx.measureText(labelText);
              ctx.fillText(labelText, labelPos.x - metrics.width - 15, labelPos.y + 5);
            }
          }

          // Dimensions and info
          ctx.fillStyle = '#374151';
          ctx.font = '12px system-ui, sans-serif';
          const infoY = pageHeight - margin;
          
          const topDDisplay = fromMM(topR * 2, unit).toFixed(2);
          const botDDisplay = fromMM(botR * 2, unit).toFixed(2);
          const heightDisplay = fromMM(h, unit).toFixed(2);
          
          ctx.fillText(`Dimensions: Top Ø${topDDisplay} × Bottom Ø${botDDisplay} × Height ${heightDisplay} ${unit}`, margin, infoY - 36);
          ctx.fillText(`Outer radius: ${fromMM(rOuter, unit).toFixed(2)} ${unit} | Inner radius: ${fromMM(rInner, unit).toFixed(2)} ${unit}`, margin, infoY - 22);
          ctx.fillText(`Total sector angle: ${(geom.theta * 180 / Math.PI).toFixed(1)}° | Scale: ${paperScale === '1' ? '1:1 (Actual Size)' : (paperScale === 'fit' ? 'Fit to page' : (parseFloat(paperScale) * 100) + '%')}`, margin, infoY - 8);

          // Convert canvas to PNG and embed in PDF
          const pngDataUrl = canvas.toDataURL('image/png', 0.95);
          
          // Convert data URL to bytes without using fetch
          const base64Data = pngDataUrl.split(',')[1];
          const binaryString = atob(base64Data);
          const pngBytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            pngBytes[i] = binaryString.charCodeAt(i);
          }
          
          const embeddedImage = await pdfDoc.embedPng(pngBytes);
          const page = pdfDoc.addPage([pageWidth, pageHeight]);
          page.drawImage(embeddedImage, {
            x: 0,
            y: 0,
            width: pageWidth,
            height: pageHeight
          });

          currentAngle = thisEnd;
          pageNum++;
        }

        const pdfBytes = await pdfDoc.save();
        return new Blob([pdfBytes], { type: 'application/pdf' });
        
      } catch (error) {
        console.error('PDF generation error:', error);
        throw error;
      }
    }

    async function openPdf() {
      const btn = document.getElementById('openPdfBtn');
      try {
        btn.disabled = true;
        showStatus('Generating PDF...', 'info');
        
        const blob = await generatePdfBlob();
        const url = URL.createObjectURL(blob);
        
        // Try to open in new tab
        const newWindow = window.open(url, '_blank');
        
        if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
          // Popup blocked - offer download instead
          showStatus('Popup blocked. Downloading PDF instead...', 'info');
          const a = document.createElement('a');
          a.href = url;
          a.download = `lampshade-template-${Date.now()}.pdf`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        } else {
          showStatus('PDF opened in new tab!', 'success');
          setTimeout(() => URL.revokeObjectURL(url), 60000);
        }
        
      } catch (err) {
        console.error('Open PDF error:', err);
        showStatus('Error: ' + (err.message || 'Failed to generate PDF'), 'error');
      } finally {
        btn.disabled = false;
      }
    }

    async function printPdf() {
      const btn = document.getElementById('printPdfBtn');
      try {
        btn.disabled = true;
        showStatus('Generating PDF for printing...', 'info');
        
        const blob = await generatePdfBlob();
        const url = URL.createObjectURL(blob);
        
        // Create hidden iframe for printing
        const iframe = document.createElement('iframe');
        iframe.style.position = 'fixed';
        iframe.style.right = '0';
        iframe.style.bottom = '0';
        iframe.style.width = '0';
        iframe.style.height = '0';
        iframe.style.border = 'none';
        document.body.appendChild(iframe);
        
        iframe.onload = function() {
          try {
            // Try to print
            iframe.contentWindow.focus();
            iframe.contentWindow.print();
            showStatus('Print dialog opened!', 'success');
            
            // Cleanup after print dialog is likely closed
            setTimeout(() => {
              document.body.removeChild(iframe);
              URL.revokeObjectURL(url);
            }, 1000);
          } catch (e) {
            console.error('Print error:', e);
            // Fallback: open in new window
            document.body.removeChild(iframe);
            const printWindow = window.open(url, '_blank');
            if (printWindow) {
              showStatus('PDF opened in new tab. Use browser print (Ctrl+P)', 'info');
            } else {
              showStatus('Popup blocked. Please allow popups or use Open PDF button.', 'error');
            }
            setTimeout(() => URL.revokeObjectURL(url), 60000);
          }
        };
        
        iframe.onerror = function() {
          showStatus('Print failed. Trying alternative method...', 'info');
          document.body.removeChild(iframe);
          
          // Fallback to new window
          const printWindow = window.open(url, '_blank');
          if (printWindow) {
            printWindow.onload = function() {
              printWindow.print();
            };
            showStatus('PDF opened for printing', 'success');
          } else {
            showStatus('Popup blocked. Please allow popups.', 'error');
          }
          setTimeout(() => URL.revokeObjectURL(url), 60000);
        };
        
        iframe.src = url;
        
      } catch (err) {
        console.error('Print PDF error:', err);
        showStatus('Error: ' + (err.message || 'Failed to print PDF'), 'error');
      } finally {
        setTimeout(() => {
          btn.disabled = false;
        }, 1000);
      }
    }

    document.getElementById('openPdfBtn').addEventListener('click', openPdf);
    document.getElementById('printPdfBtn').addEventListener('click', printPdf);

    // Check if PDF library loaded on page load
    window.addEventListener('load', () => {
      setTimeout(() => {
        if (!window.PDFLib && !window['pdf-lib']) {
          showStatus('Warning: PDF library may not have loaded. Please refresh if you encounter errors.', 'error');
        }
      }, 2000);
    });
  </script>
</body>
</html>
